#import modules import arcpy import sys import os import csv  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True
project = arcpy.mp.ArcGISProject("CURRENT")
maps = project.listMaps()
maps
maps[0]
map = maps[0]
layers = map.listLayers()
layers
layers[0]
layer = layers[0]
layer.dataSource.fget()
layer.dataSource
layer.isRasterLayer
layer.listTables()
raster = arcpy.Raster('USGS_13_n44w078.tif')
raster
import numpy as np
arr = arcpy.RasterToNumPyArray(raster)
arr
arr.shape
raster.extent
print(raster.extent)
raster.extent.spatial_reference
raster.extent
import arcpy
raster = arcpy.ListRasters()[0]
raster = arcpy.Raster('USGS_13_n44w078.tif')
raster.extent
raster.extent.x
raster.extent['x']
raster.extent.XMin
raster.extent.XMax
"C:\\Users\\Chrys\\Dropbox\\RIT\\2231\\IGME 386\\Final\\scripts\\main.py"
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": new_extent.height / y_increment,         "width": new_extent.width / x_increment     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      # fill with arr1     arr1_offset = {         "x": (raster1.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster1.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr1):         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(name1, name2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": new_extent.height / y_increment,         "width": new_extent.width / x_increment     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      # fill with arr1     arr1_offset = {         "x": (raster1.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster1.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr1):         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
new_arr.shape
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         print("arr1 shape", arr1.shape)         print("index", index)         print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height * y_increment),         "width": int(new_extent.width * x_increment)     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         print("arr1 shape", arr1.shape)         print("index", index)         print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height * y_increment),         "width": int(new_extent.width * x_increment)     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         print("arr1 shape", arr1.shape)         print("index", index)         print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height * y_increment),         "width": int(new_extent.width * x_increment)     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         print("arr1 shape", arr1.shape)         print("index", index)         print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height * y_increment),         "width": int(new_extent.width * x_increment)     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         print("arr1 shape", arr1.shape)         print("index", index)         print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
raster.extent
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         print("arr1 shape", arr1.shape)         print("index", index)         print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         # print("arr1 shape", arr1.shape)         # print("index", index)         # print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment)+1,         "width": int(new_extent.width / x_increment)+1     }     new_arr = np.zeros((new_dimensions['width'], new_dimensions['height']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         # print("arr1 shape", arr1.shape)         # print("index", index)         # print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         # print("arr1 shape", arr1.shape)         # print("index", index)         # print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": (raster2.extent.XMin - new_extent.XMin)/x_increment,         "y": (raster2.extent.YMin - new_extent.YMin)/y_increment     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         # print("arr1 shape", arr1.shape)         # print("index", index)         # print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr1):         # print("arr1 shape", arr1.shape)         print("index", index)         print("value", value)         new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr2):         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     # arr1_offset = {     #     "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     # }     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr2):         print("index", index)         print("value", value)         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     # arr1_offset = {     #     "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     # }     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result = merge(raster1, raster2)     arcpy.CopyRaster_management(result, os.path.join(scripts_directory, 'merge_output.tif'))     map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     # arr1_offset = {     #     "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     # }     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value      result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       new_arr[100, 100] = 255       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         new_arr[x, x] = 255       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         print("setting value!: ", x)         new_arr[x, x] = 255       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
result_b.spatialReference
print(result_b.spatialReference)
print(result_b.spatialReference.na)
result_b.spatialReference.name
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         print("setting value!: ", x)         new_arr[x, x] = 255       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     result_a.SpatialReference = spatialReference     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
result_b.setSpatialReference
result_b.SpatialReference
result_b.SpatialReference.na
result_b.SpatialReference.name
result_b.spatialReference.name
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         print("setting value!: ", x)         new_arr[x, x] = 255       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     result_a.spatialReference = spatialReference     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         print("setting value!: ", x)         new_arr[x, x] = 255       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     # result_a.spatialReference = spatialReference     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         print("setting value!: ", x)         new_arr[x, x] = 255         new_arr[x, x+1] = 255         new_arr[x, x+2] = 255         new_arr[x, x+3] = 255         new_arr[x, x+4] = 255         new_arr[x, x+5] = 255       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     # result_a.spatialReference = spatialReference     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         print("setting value!: ", x)         new_arr[x, x] = x+255         new_arr[x, x+1] = x+255         new_arr[x, x+2] = x+255         new_arr[x, x+3] = x+255         new_arr[x, x+4] = x+255         new_arr[x, x+5] = x+255       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         print("setting value!: ", x)         val = 128         new_arr[x, x] = val         new_arr[x, x+1] = val         new_arr[x, x+2] = val         new_arr[x, x+3] = val         new_arr[x, x+4] = val         new_arr[x, x+5] = val       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]+arr2_offset['y'], index[1]+arr2_offset['x']] = value       for x in range(500):         print("setting value!: ", x)         val = 128         new_arr[x, x] = val         new_arr[x, x+1] = val         new_arr[x, x+2] = val         new_arr[x, x+3] = val         new_arr[x, x+4] = val         new_arr[x, x+5] = val+1       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
del result_b
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMin - new_extent.YMin)/y_increment)     }     print("arr1_offset", arr1_offset)     # for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)     #     new_arr[index[0]+arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       # for x in range(500):     #     print("setting value!: ", x)     #     val = 128     #     new_arr[x, x] = val     #     new_arr[x, x+1] = val     #     new_arr[x, x+2] = val     #     new_arr[x, x+3] = val     #     new_arr[x, x+4] = val     #     new_arr[x, x+5] = val+1       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       # for x in range(500):     #     print("setting value!: ", x)     #     val = 128     #     new_arr[x, x] = val     #     new_arr[x, x+1] = val     #     new_arr[x, x+2] = val     #     new_arr[x, x+3] = val     #     new_arr[x, x+4] = val     #     new_arr[x, x+5] = val+1       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     # print("Copying array 2")     # arr2_offset = {     #     "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     # }     # print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       # for x in range(500):     #     print("setting value!: ", x)     #     val = 128     #     new_arr[x, x] = val     #     new_arr[x, x+1] = val     #     new_arr[x, x+2] = val     #     new_arr[x, x+3] = val     #     new_arr[x, x+4] = val     #     new_arr[x, x+5] = val+1       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       # for x in range(500):     #     print("setting value!: ", x)     #     val = 128     #     new_arr[x, x] = val     #     new_arr[x, x+1] = val     #     new_arr[x, x+2] = val     #     new_arr[x, x+3] = val     #     new_arr[x, x+4] = val     #     new_arr[x, x+5] = val+1       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment) + 700,         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax)+700,         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment) + 700,         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)+700     }     new_arr = np.zeros((new_dimensions['height'], new_dimensions['width']))      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment) + 700,         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)+700     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment) + 700,         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
arr1 = np.zeroes((4,4))
arr1 = np.full((4,4))
arr1 = np.full((4,4), None)
arr1
arr1 = np.zeros((4,4))
arr1
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)+700     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment) + 700,         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a      if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_fast(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]     # for index, value in np.ndenumerate(arr1):     # #     # print("arr1 shape", arr1.shape)     # #     print("index", index)     # #     print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     # print("Copying array 2")     # arr2_offset = {     #     "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     # }     # # print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge_fast(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
raster1.noDataValue
raster1.noDataValues
raster1.noDataValue
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_fast(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=None)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=None)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]     # for index, value in np.ndenumerate(arr1):     # #     # print("arr1 shape", arr1.shape)     # #     print("index", index)     # #     print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     # print("Copying array 2")     # arr2_offset = {     #     "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     # }     # # print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge_fast(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_fast(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=999999.0)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=999999.0)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]     # for index, value in np.ndenumerate(arr1):     # #     # print("arr1 shape", arr1.shape)     # #     print("index", index)     # #     print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     # print("Copying array 2")     # arr2_offset = {     #     "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     # }     # # print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge_fast(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_fast(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=-999999.0)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=-999999.0)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]     # for index, value in np.ndenumerate(arr1):     # #     # print("arr1 shape", arr1.shape)     # #     print("index", index)     # #     print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     # print("Copying array 2")     # arr2_offset = {     #     "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     # }     # # print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge_fast(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_fast(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=np.nan)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=np.nan)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]     # for index, value in np.ndenumerate(arr1):     # #     # print("arr1 shape", arr1.shape)     # #     print("index", index)     # #     print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     # print("Copying array 2")     # arr2_offset = {     #     "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),     #     "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     # }     # # print("arr2_offset", arr2_offset)     # for index, value in np.ndenumerate(arr2):     #     # print("index", index)     #     # print("value", value)     #     if value < 0:     #         value = None     #     new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge_fast(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_fast(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=np.nan)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=np.nan)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     tgt_x_begin = arr2_offset['x']     tgt_x_end = arr2_offset['x'] + arr2.shape[1]     tgt_y_begin = arr2_offset['y']     tgt_y_end = arr2_offset['y'] + arr2.shape[0]     src_x_begin = 0     src_x_end = arr2.shape[1]     src_y_begin = 0     src_y_end = arr2.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr2[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge_fast(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_fast(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=np.nan)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=np.nan)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     tgt_x_begin = arr2_offset['x']     tgt_x_end = arr2_offset['x'] + arr2.shape[1]     tgt_y_begin = arr2_offset['y']     tgt_y_end = arr2_offset['y'] + arr2.shape[0]     src_x_begin = 0     src_x_end = arr2.shape[1]     src_y_begin = 0     src_y_end = arr2.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr2[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)     result_b = merge_fast(raster1, raster2)     arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import modules import arcpy import sys import os import csv import numpy as np import time  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True  # Practice: Make something to merge DEM's def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_fast(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=np.nan)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=np.nan)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     tgt_x_begin = arr2_offset['x']     tgt_x_end = arr2_offset['x'] + arr2.shape[1]     tgt_y_begin = arr2_offset['y']     tgt_y_end = arr2_offset['y'] + arr2.shape[0]     src_x_begin = 0     src_x_end = arr2.shape[1]     src_y_begin = 0     src_y_end = arr2.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr2[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)      slow_start = time.time()     result_a = merge_slow(raster1, raster2)     slow_end = time.time()      fast_start = time.time()     result_b = merge_fast(raster1, raster2)     fast_end = time.time()       print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import sys import os import time  import csv import numpy as np import arcpy # Import project modules import utils  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True    if __name__ == "__main__":           # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     fast_end = time.time()      multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import sys import os import time  import csv import numpy as np import arcpy # Import project modules import utils  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True    if __name__ == "__main__":     print(os.getcwd())      # Get the acitve project in ArcGIS Pro     project = arcpy.mp.ArcGISProject("CURRENT")      # The directory where data will be processed     project_directory = os.path.dirname(project.filePath)     scripts_directory = os.path.join(project_directory, "scripts")     data_directory = os.path.join(project_directory, "data")      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     fast_end = time.time()      multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
os.getcwd()
#import library modules import sys import os import time  import csv import numpy as np import arcpy    # setup script metadata for project imports project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory:     sys.path.insert(1, scripts_directory)  # Import project modules import utils  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   if __name__ == "__main__":      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     fast_end = time.time()      multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import sys import os import time  import csv import numpy as np import arcpy    # setup script metadata for project imports project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory:     sys.path.insert(1, scripts_directory)  # Import project modules import utils  # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   if __name__ == "__main__":      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
utils.merge_rasters()
utils.merge_rasters([])
utils.merge_rasters([raster1, raster2])
import utils
utils.merge_rasters([raster1, raster2])
del utils
import utils
utils.merge_rasters([raster1, raster2])
del utils
utils.merge_rasters([raster1, raster2])
import utils
utils.merge_rasters([raster1, raster2])
#import library modules import sys import os import time  import importlib  import csv import numpy as np import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils else: # rerun requires reimports     importlib.reload(utils)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   if __name__ == "__main__":      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
utils.merge_rasters([raster1, raster2])
#import library modules import sys import os import time  import importlib  import csv import numpy as np import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils else: # rerun requires reimports     importlib.reload(utils)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   if __name__ == "__main__":      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
utils.merge_rasters([raster1, raster2])
#import library modules import sys import os import time  import importlib  import csv import numpy as np import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils else: # rerun requires reimports     importlib.reload(utils)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   if __name__ == "__main__":      map = project.listMaps()[0]      # Test operations!     name1 = 'USGS_13_n44w078.tif'     name2 = 'USGS_13_n43w078.tif'     raster1 = arcpy.Raster(name1)     raster2 = arcpy.Raster(name2)      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
utils.merge_rasters([raster1, raster2])
#import library modules import functools import numpy as np import arcpy  # Practice: Make something to merge Rasters def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth     y_increment = raster1.meanCellHeight     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_raster(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=np.nan)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=np.nan)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     tgt_x_begin = arr2_offset['x']     tgt_x_end = arr2_offset['x'] + arr2.shape[1]     tgt_y_begin = arr2_offset['y']     tgt_y_end = arr2_offset['y'] + arr2.shape[0]     src_x_begin = 0     src_x_end = arr2.shape[1]     src_y_begin = 0     src_y_end = arr2.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr2[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a  def combine_extents(extent1: arcpy.Extent, extent2: arcpy.Extent):     print("extent1", extent1)     print("extent2", extent2)     extent2 = extent2.projectAs(extent1.spatialReference)     print("extent2 projected", extent2)     return arcpy.Extent(         XMin=min(extent1.XMin, extent2.XMin),         XMax=max(extent1.XMax, extent2.XMax),         YMin=min(extent1.YMin, extent2.YMin),         YMax=max(extent1.YMax, extent2.YMax),         spatial_reference=extent1.spatialReference,     )  def merge_rasters(rasters):     if len(rasters) == 0:         return None          # assuming each raster is the same, use these parameters from the first     spatialReference = arcpy.Describe(rasters[0]).spatialReference     x_increment = rasters[0].meanCellWidth     y_increment = rasters[0].meanCellHeight          new_extent = functools.reduce(lambda e, r: combine_extents(e, r.extent), rasters, arcpy.Extent(spatial_reference=spatialReference))       new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)     print("new_arr shape", new_arr.shape)           for raster in rasters:         arr = arcpy.RasterToNumPyArray(raster, nodata_to_value=np.nan)         arr_offset = {             "x": int((raster.extent.XMin - new_extent.XMin)/x_increment),             "y": -int((raster.extent.YMax - new_extent.YMax)/y_increment)         }         print("arr_offset", arr_offset)          tgt_x_begin = arr_offset['x']         tgt_x_end = arr_offset['x'] + arr.shape[1]         tgt_y_begin = arr_offset['y']         tgt_y_end = arr_offset['y'] + arr.shape[0]         src_x_begin = 0         src_x_end = arr.shape[1]         src_y_begin = 0         src_y_end = arr.shape[0]         new_arr[             tgt_y_begin: tgt_y_end,             tgt_x_begin: tgt_x_end         ] = arr[             src_y_begin: src_y_end,             src_x_begin: src_x_end         ]      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result, spatialReference)     return result
merge_rasters([raster1, raster2])
#import library modules import functools import numpy as np import arcpy  # Practice: Make something to merge Rasters def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth     y_increment = raster1.meanCellHeight     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_raster(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=np.nan)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=np.nan)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     tgt_x_begin = arr2_offset['x']     tgt_x_end = arr2_offset['x'] + arr2.shape[1]     tgt_y_begin = arr2_offset['y']     tgt_y_end = arr2_offset['y'] + arr2.shape[0]     src_x_begin = 0     src_x_end = arr2.shape[1]     src_y_begin = 0     src_y_end = arr2.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr2[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a  def combine_extents(extent1: arcpy.Extent, extent2: arcpy.Extent):     print("extent1", extent1)     print("extent2", extent2)     extent2 = extent2.projectAs(extent1.spatialReference)     print("extent2 projected", extent2)     return arcpy.Extent(         XMin=min(extent1.XMin, extent2.XMin),         XMax=max(extent1.XMax, extent2.XMax),         YMin=min(extent1.YMin, extent2.YMin),         YMax=max(extent1.YMax, extent2.YMax),         spatial_reference=extent1.spatialReference,     )  def merge_rasters(rasters):     if len(rasters) == 0:         return None          # assuming each raster is the same, use these parameters from the first          x_increment = rasters[0].meanCellWidth     y_increment = rasters[0].meanCellHeight          new_extent = functools.reduce(lambda e, r: combine_extents(e, r.extent), rasters)     spatialReference = new_extent.spatialReference       new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)     print("new_arr shape", new_arr.shape)           for raster in rasters:         arr = arcpy.RasterToNumPyArray(raster, nodata_to_value=np.nan)         arr_offset = {             "x": int((raster.extent.XMin - new_extent.XMin)/x_increment),             "y": -int((raster.extent.YMax - new_extent.YMax)/y_increment)         }         print("arr_offset", arr_offset)          tgt_x_begin = arr_offset['x']         tgt_x_end = arr_offset['x'] + arr.shape[1]         tgt_y_begin = arr_offset['y']         tgt_y_end = arr_offset['y'] + arr.shape[0]         src_x_begin = 0         src_x_end = arr.shape[1]         src_y_begin = 0         src_y_end = arr.shape[0]         new_arr[             tgt_y_begin: tgt_y_end,             tgt_x_begin: tgt_x_end         ] = arr[             src_y_begin: src_y_end,             src_x_begin: src_x_end         ]      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result, spatialReference)     return result
merge_rasters([raster1, raster2])
#import library modules import functools import numpy as np import arcpy  # Practice: Make something to merge Rasters def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth     y_increment = raster1.meanCellHeight     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_raster(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=np.nan)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=np.nan)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     tgt_x_begin = arr2_offset['x']     tgt_x_end = arr2_offset['x'] + arr2.shape[1]     tgt_y_begin = arr2_offset['y']     tgt_y_end = arr2_offset['y'] + arr2.shape[0]     src_x_begin = 0     src_x_end = arr2.shape[1]     src_y_begin = 0     src_y_end = arr2.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr2[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a  def combine_extents(extent1: arcpy.Extent, extent2: arcpy.Extent):     if isinstance(extent1, arcpy.Raster):         extent1 = extent1.extent     if isinstance(extent2, arcpy.Raster):         extent2 = extent2.extent     print("extent1", extent1)     print("extent2", extent2)     extent2 = extent2.projectAs(extent1.spatialReference)     print("extent2 projected", extent2)     return arcpy.Extent(         XMin=min(extent1.XMin, extent2.XMin),         XMax=max(extent1.XMax, extent2.XMax),         YMin=min(extent1.YMin, extent2.YMin),         YMax=max(extent1.YMax, extent2.YMax),         spatial_reference=extent1.spatialReference,     )  def merge_rasters(rasters):     if len(rasters) == 0:         return None          # assuming each raster is the same, use these parameters from the first          x_increment = rasters[0].meanCellWidth     y_increment = rasters[0].meanCellHeight          new_extent = functools.reduce(combine_extents, rasters)     spatialReference = new_extent.spatialReference       new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)     print("new_arr shape", new_arr.shape)           for raster in rasters:         arr = arcpy.RasterToNumPyArray(raster, nodata_to_value=np.nan)         arr_offset = {             "x": int((raster.extent.XMin - new_extent.XMin)/x_increment),             "y": -int((raster.extent.YMax - new_extent.YMax)/y_increment)         }         print("arr_offset", arr_offset)          tgt_x_begin = arr_offset['x']         tgt_x_end = arr_offset['x'] + arr.shape[1]         tgt_y_begin = arr_offset['y']         tgt_y_end = arr_offset['y'] + arr.shape[0]         src_x_begin = 0         src_x_end = arr.shape[1]         src_y_begin = 0         src_y_end = arr.shape[0]         new_arr[             tgt_y_begin: tgt_y_end,             tgt_x_begin: tgt_x_end         ] = arr[             src_y_begin: src_y_end,             src_x_begin: src_x_end         ]      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result, spatialReference)     return result
merge_rasters([raster1, raster2])
#import library modules import sys import os import time  import importlib  import csv import numpy as np import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils else: # rerun requires reimports     utils = importlib.reload(utils)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   if __name__ == "__main__":     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2, raster3])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
result_b1 = utils.merge_raster(result_b, raster3)
#import library modules import sys import os import time  import importlib  import csv import numpy as np import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils else: # rerun requires reimports     utils = importlib.reload(utils)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   if __name__ == "__main__":     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import functools import numpy as np import arcpy  # Practice: Make something to merge Rasters def merge_slow(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1)     arr2 = arcpy.RasterToNumPyArray(raster2)      x_increment = raster1.meanCellWidth     y_increment = raster1.meanCellHeight     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), None, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     for index, value in np.ndenumerate(arr1):     #     # print("arr1 shape", arr1.shape)     #     print("index", index)     #     print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr1_offset['y'], index[1]+arr1_offset['x']] = value      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     # print("arr2_offset", arr2_offset)     for index, value in np.ndenumerate(arr2):         # print("index", index)         # print("value", value)         if value < 0:             value = None         new_arr[index[0]-arr2_offset['y'], index[1]+arr2_offset['x']] = value       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a   def merge_raster(raster1, raster2):     spatialReference = arcpy.Describe(raster1).spatialReference     print("raster 1 extent:", raster1.extent)     print("raster 2 extent:", raster2.extent)     new_extent = arcpy.Extent(         XMin=min(raster1.extent.XMin, raster2.extent.XMin),         XMax=max(raster1.extent.XMax, raster2.extent.XMax),         YMin=min(raster1.extent.YMin, raster2.extent.YMin),         YMax=max(raster1.extent.YMax, raster2.extent.YMax),     )     print("new_extent:", new_extent)     print("new_extent.height",  new_extent.height)     arr1 = arcpy.RasterToNumPyArray(raster1, nodata_to_value=np.nan)     arr2 = arcpy.RasterToNumPyArray(raster2, nodata_to_value=np.nan)      x_increment = raster1.meanCellWidth # raster1.extent.XMax - raster1.extent.XMin     y_increment = raster1.meanCellHeight # raster1.extent.YMax - raster1.extent.YMin     new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)      print("new_arr shape", new_arr.shape)      # fill with arr1     # print("Copying array 1")     arr1_offset = {         "x": int((raster1.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster1.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr1_offset", arr1_offset)     tgt_x_begin = arr1_offset['x']     tgt_x_end = arr1_offset['x'] + arr1.shape[1]     tgt_y_begin = arr1_offset['y']     tgt_y_end = arr1_offset['y'] + arr1.shape[0]     src_x_begin = 0     src_x_end = arr1.shape[1]     src_y_begin = 0     src_y_end = arr1.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr1[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]      # fill with arr2     print("Copying array 2")     arr2_offset = {         "x": int((raster2.extent.XMin - new_extent.XMin)/x_increment),         "y": -int((raster2.extent.YMax - new_extent.YMax)/y_increment)     }     print("arr2_offset", arr2_offset)     tgt_x_begin = arr2_offset['x']     tgt_x_end = arr2_offset['x'] + arr2.shape[1]     tgt_y_begin = arr2_offset['y']     tgt_y_end = arr2_offset['y'] + arr2.shape[0]     src_x_begin = 0     src_x_end = arr2.shape[1]     src_y_begin = 0     src_y_end = arr2.shape[0]     new_arr[         tgt_y_begin: tgt_y_end,         tgt_x_begin: tgt_x_end     ] = arr2[         src_y_begin: src_y_end,         src_x_begin: src_x_end     ]       result_a = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result_a, spatialReference)     return result_a  def combine_extents(extent1: arcpy.Extent, extent2: arcpy.Extent):     if isinstance(extent1, arcpy.Raster):         extent1 = extent1.extent     if isinstance(extent2, arcpy.Raster):         extent2 = extent2.extent     print("extent1", extent1)     print("extent2", extent2)     extent2 = extent2.projectAs(extent1.spatialReference)     print("extent2 projected", extent2)     return arcpy.Extent(         XMin=min(extent1.XMin, extent2.XMin),         XMax=max(extent1.XMax, extent2.XMax),         YMin=min(extent1.YMin, extent2.YMin),         YMax=max(extent1.YMax, extent2.YMax),         spatial_reference=extent1.spatialReference,     )  def merge_rasters(rasters):     if len(rasters) == 0:         return None          # assuming each raster is the same, use these parameters from the first          x_increment = rasters[0].meanCellWidth     y_increment = rasters[0].meanCellHeight          new_extent = functools.reduce(combine_extents, rasters)     spatialReference = new_extent.spatialReference       new_dimensions = {         "height": int(new_extent.height / y_increment),         "width": int(new_extent.width / x_increment)     }     new_arr = np.full((new_dimensions['height'], new_dimensions['width']), np.nan, float)     print("new_arr shape", new_arr.shape)           for raster in rasters:         arr = arcpy.RasterToNumPyArray(raster, nodata_to_value=np.nan)         arr_offset = {             "x": int((raster.extent.XMin - new_extent.XMin)/x_increment),             "y": -int((raster.extent.YMax - new_extent.YMax)/y_increment)         }         print("arr_offset", arr_offset)          tgt_x_begin = arr_offset['x']         tgt_x_end = arr_offset['x'] + arr.shape[1]         tgt_y_begin = arr_offset['y']         tgt_y_end = arr_offset['y'] + arr.shape[0]         src_x_begin = 0         src_x_end = arr.shape[1]         src_y_begin = 0         src_y_end = arr.shape[0]         new_arr[             tgt_y_begin: tgt_y_end,             tgt_x_begin: tgt_x_end         ] = arr[             src_y_begin: src_y_end,             src_x_begin: src_x_end         ]      result = arcpy.NumPyArrayToRaster(new_arr, new_extent.lowerLeft, x_increment, y_increment)     arcpy.DefineProjection_management(result, spatialReference)     return result
ws = Watershed()
import numpy as np import arcpy  import utils    class Watershed:     def __init__(self) -> None:         self.rasters = []         self.complete_raster = None         self.point = None      def IncludeRaster(self, raster):         self.rasters.append(raster)         self.complete_raster = None         if len(self.rasters) == 1:             self.complete_raster = self.rasters[0]      def compile_rasters(self):         if self.complete_raster is None:             self.complete_raster = utils.merge_rasters(self.rasters)      def set_point(self, point):         self.point = point      def find_min(self):         self.compile_rasters()         if self.complete_raster is None:             return None                  arr = arcpy.RasterToNumPyArray(self.complete_raster, nodata_to_value=np.nan)         min = np.argmin(arr)                  # for index, value in np.ndenumerate(arr):         return min
ws = Watershed()
ws.IncludeRaster(raster1)
ws.find_min()
import numpy as np import arcpy  import utils    class Watershed:     def __init__(self) -> None:         self.rasters = []         self.complete_raster = None         self.point = None      def IncludeRaster(self, raster):         self.rasters.append(raster)         self.complete_raster = None         if len(self.rasters) == 1:             self.complete_raster = self.rasters[0]      def compile_rasters(self):         if self.complete_raster is None:             self.complete_raster = utils.merge_rasters(self.rasters)      def set_point(self, point):         self.point = point      def find_min(self):         self.compile_rasters()         if self.complete_raster is None:             return None                  arr = arcpy.RasterToNumPyArray(self.complete_raster, nodata_to_value=np.nan)         # min_val = np.argmin(arr)         min_val = float("inf")         min_index = None         for index, value in np.ndenumerate(arr):             if value is np.nan:                 continue             if value < min_val:                 min_val = value                 min_index = index         return min_index
ws = Watershed()
ws.find_min()
print(ws.find_min())
ws.IncludeRaster(raster1)
print(ws.find_min())
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     ws.IncludeRaster(raster2)      output = ws.find_watershed()   if __name__ == "__main__":     # test_operations()     find_watershed()      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     ws.IncludeRaster(raster2)      point = arcpy.Point(-77.6989588, 43.0640209)      return ws.find_watershed(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      ws = watershed.Watershed(slope_tolerance=0.2)     ws.IncludeRaster(raster1)     ws.IncludeRaster(raster2)      point = arcpy.Point(-77.6989588, 43.0640209)      return ws.find_watershed(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     # ws.IncludeRaster(raster2)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.2)     return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_HR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1_HR)     # ws.IncludeRaster(raster2)      point = arcpy.Point(-77.6989588, 43.0640209)      return ws.find_watershed_simple(point)     # return ws.find_watershed_simple(point, slope_tolerance=0.2)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()      # arcpy.CopyRaster_management(result_b, os.path.join(scripts_directory, 'merge_output.tif'))     # del result_b     # map.addDataFromPath(os.path.join(scripts_directory, 'merge_output.tif'))             # Create Watershed Object, init with a point # Load with One or more DEM's into a pool # find first dem that contains start point # Use the resolution and grid from this dem as the basis # iterate from start point up and down slopes # if there is a connected slope at an edge, #   search for a dem from the pool to use by adding to the active set, #   if not mark this point as an inflow or an outflow. # For all processed points, add to the watershed set. (convert to polygon later) # For all processed points, calculate flow angle (produce raster from this)
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_HR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1_HR)     # ws.IncludeRaster(raster2)      point = arcpy.Point(-77.6989588, 43.0640209)      return ws.find_watershed_simple(point, slope_tolerance=0.05)     # return ws.find_watershed_simple(point, slope_tolerance=0.2)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_HR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1_HR)     # ws.IncludeRaster(raster2)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.2)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_HR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1_HR)     # ws.IncludeRaster(raster2)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.0, neighborhood_radius=2)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_HR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1_HR)     # ws.IncludeRaster(raster2)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.0, neighborhood_radius=1)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     # ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.0, neighborhood_radius=1)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     # ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.0, neighborhood_radius=2)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     # ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.0, neighborhood_radius=3)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     # ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.2, neighborhood_radius=3)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.00, neighborhood_radius=3)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.00, neighborhood_radius=5)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     output = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     # ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.00, neighborhood_radius=3)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     (ws, inflows) = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     # ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.00, neighborhood_radius=1)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     (ws, inflows) = find_watershed()
#import library modules import sys import os import time  import importlib  import arcpy  # setup script metadata for project imports for use in arcpy project = arcpy.mp.ArcGISProject("CURRENT") project_directory = os.path.dirname(project.filePath) scripts_directory = os.path.join(project_directory, "scripts") data_directory = os.path.join(project_directory, "data") if sys.path[0] != scripts_directory: # fresh run     sys.path.insert(1, scripts_directory)      # Import project modules     import utils     import watershed else: # rerun requires reimports     utils = importlib.reload(utils)     watershed = importlib.reload(watershed)   # To allow overwriting the outputs change the overwrite option to true. arcpy.env.overwriteOutput = True   def test_operations():     # Test operations!     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')     raster3 = arcpy.Raster('USGS_13_n43w077.tif')      # slow_start = time.time()     # result_a = utils.merge_slow(raster1, raster2)     # slow_end = time.time()      print("using merge")     fast_start = time.time()     result_b = utils.merge_raster(raster1, raster2)     # result_b1 = utils.merge_raster(result_b, raster3)     fast_end = time.time()      print("using multi merge")     multi_start = time.time()     result_c = utils.merge_rasters([raster1, raster2])     multi_end = time.time()      # print("Slow: ", slow_end-slow_start)     print("Fast: ", fast_end-fast_start)     print("Multi: ", multi_end-multi_start)  def find_watershed():     # High res     raster1 = arcpy.Raster('USGS_13_n44w078.tif')     raster2 = arcpy.Raster('USGS_13_n43w078.tif')      # Low res     raster1_LR = arcpy.Raster('USGS_1_n44w078.tif')      ws = watershed.Watershed()     ws.IncludeRaster(raster1)     # ws.IncludeRaster(raster2)     # ws.IncludeRaster(raster1_LR)      point = arcpy.Point(-77.6989588, 43.0640209)      # return ws.find_watershed_simple(point, slope_tolerance=0.05)     return ws.find_watershed_simple(point, slope_tolerance=0.00, neighborhood_radius=3)     # return ws.find_watershed_rainfill(point)   if __name__ == "__main__":     # test_operations()     (ws, inflows) = find_watershed()
